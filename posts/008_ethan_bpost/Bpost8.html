<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ethan Roytman">
<meta name="dcterms.date" content="2025-03-01">
<meta name="description" content="Testing Chat GPT’s ability to circumvent AI Detectors">

<title>Can Chat GPT beat itself? – Ethans LLM Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-listing/list.min.js"></script>
<script src="../../site_libs/quarto-listing/quarto-listing.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-d4d76bf8491c20bad77d141916dc28e1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-cfb8d544f4d1b28d19f315c4af124635.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script>

  window.document.addEventListener("DOMContentLoaded", function (_event) {
    const listingTargetEl = window.document.querySelector('#listing-listing .list');
    if (!listingTargetEl) {
      // No listing discovered, do not attach.
      return; 
    }

    const options = {
      valueNames: ['listing-title','listing-author','listing-date','listing-categories','listing-description',{ data: ['index'] },{ data: ['categories'] },{ data: ['listing-date-sort'] },{ data: ['listing-file-modified-sort'] }],
      
      searchColumns: [],
    };

    window['quarto-listings'] = window['quarto-listings'] || {};
    window['quarto-listings']['listing-listing'] = new List('listing-listing', options);

    if (window['quarto-listing-loaded']) {
      window['quarto-listing-loaded']();
    }
  });

  window.addEventListener('hashchange',() => {
    if (window['quarto-listing-loaded']) {
      window['quarto-listing-loaded']();
    }
  })
  </script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Ethans LLM Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Can Chat GPT beat itself?</h1>
                  <div>
        <div class="description">
          Testing Chat GPT’s ability to circumvent AI Detectors
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">LLMs</div>
                <div class="quarto-category">Image Rxecreation</div>
                <div class="quarto-category">AI reasoning</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Ethan Roytman </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 1, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Chat GPT has a feature where it has multiple “Custom GPTs” on its site; these include “Code Copilot,”Sora”, and today’s star “AI Humanizer.” I will initially feed it an outline for my Op-Ed from my freshman year writing seminar and tell it to write an Op-ed using it. Then I am going to run it through GPT 0 and see the AI result. After that, I will put it through “AI Humanizer” and other GPT humanizer bots to see if it can lower the overall AI score or even get through the detector altogether.</p>
</section>
<section id="produced-op-ed" class="level1">
<h1>Produced Op-Ed</h1>
<p><strong>Stop Letting Algorithms Decide Who Gets Policed</strong><br>
By Ethan Roytman</p>
<p>Imagine being labeled a criminal risk—not because of anything you’ve done, but because of where you live or the color of your skin. In many communities across America, this is not just a hypothetical scenario. It’s the reality created by predictive policing algorithms.</p>
<p>Predictive policing, a strategy increasingly adopted by law enforcement agencies, uses data to anticipate where crimes are likely to occur and who might commit them. On the surface, this sounds like a sensible, even progressive, use of technology to make communities safer. But peel back the layers, and a disturbing truth emerges: these algorithms too often reinforce systemic biases and deepen long-standing inequalities.</p>
<p>Predictive policing relies on historical crime data—data that is anything but neutral. Years of over-policing in certain neighborhoods, especially those with higher populations of Black, Latino, and low-income residents, have produced skewed statistics. These areas show up in the data as “high-risk” not necessarily because they experience more crime, but because they have been subject to more policing and arrests. When algorithms crunch this data, they perpetuate the same patterns, marking these neighborhoods for even more policing. The result? A vicious cycle where bias feeds bias, and the people who have already suffered the most continue to be targeted.</p>
<p>Consider a neighborhood with a high number of reported thefts. If this neighborhood has been over-policed for decades, its crime statistics will naturally be higher. Predictive algorithms then flag it as a hotspot, prompting even more patrols, arrests, and surveillance. But is this truly preventing crime? Or is it simply magnifying a distorted image created by the unequal application of justice?</p>
<p>Worse yet, these tools divert attention and resources away from addressing the actual causes of crime. Poverty, lack of access to education, housing insecurity, and inadequate social services are all significant contributors to criminal behavior. Yet rather than investing in community programs, job creation, or mental health services, cities pour money into technology that tells police to go back to the same places they have always patrolled more heavily. Predictive policing does not reduce crime—it reinforces it by failing to address its roots.</p>
<p>Advocates of predictive policing argue that these algorithms can make law enforcement more efficient by detecting trends that officers might miss. They claim that technology can help deploy limited police resources more effectively. While it is true that data can help identify patterns, the problem is not with data itself—but with the flawed data we feed into these systems. If the input reflects inequality, so too will the output. No algorithm, however sophisticated, can solve a problem it does not understand.</p>
<p>We must ask ourselves: efficiency for whom? If efficiency comes at the expense of fairness, justice, and trust, is it worth it? The answer should be no. Policing should not be about upholding patterns; it should be about protecting people—all people—equally.</p>
<p>Ending the use of predictive policing algorithms is not about rejecting technology outright. It is about ensuring that our solutions do not perpetuate the very injustices we hope to solve. We need tools that confront the root causes of crime, not those that merely reinforce harmful stereotypes.</p>
<p>As a nation reckoning with the realities of systemic racism and mass incarceration, we cannot afford to let algorithms dictate who gets policed and who does not. The government must stop relying on predictive policing algorithms and instead invest in communities, social services, and policies that offer real public safety.</p>
<section id="original-ai-score" class="level3">
<h3 class="anchored" data-anchor-id="original-ai-score">Original AI Score</h3>
<p>78% AI-generated 1% Mixed 21% Human</p>
<p>Honestly, for a completely ChatGPT-generated response, 78% is not a bad AI generation score. Granted, I gave ChatGPT a human outline to base the essay on, but it was still lower than I expected.</p>
</section>
</section>
<section id="humanizer-version" class="level1">
<h1>Humanizer Version</h1>
<p>After running it through the “AI Humanizer” GPT, it generated the following:</p>
<section id="stop-letting-algorithms-decide-who-gets-policed" class="level3">
<h3 class="anchored" data-anchor-id="stop-letting-algorithms-decide-who-gets-policed">Stop Letting Algorithms Decide Who Gets Policed</h3>
<p>By Ethan Roytman</p>
<p>Imagine being labeled a criminal threat—not because of anything you’ve done, but because of where you live or the color of your skin. For many communities across America, this isn’t a dystopian thought experiment. It’s their everyday reality, thanks to predictive policing algorithms.</p>
<p>This approach, which is gaining traction among police departments nationwide, claims to use data to forecast where crimes will happen and who might commit them. At first glance, it sounds practical—even innovative. Technology, after all, is often seen as a tool to make things fairer and more efficient. But when you dig deeper, a troubling truth emerges: these algorithms aren’t eliminating bias—they’re automating it.</p>
<p>The problem starts with the data itself. Predictive policing systems rely on historical crime statistics, but those numbers come from decades of discriminatory policing practices. Black, Latino, and low-income neighborhoods have long been subject to over-policing. The result? Skewed data that paints these communities as inherently more dangerous—not because they are, but because they’ve been watched more closely and punished more harshly. Algorithms then take this flawed data, process it, and spit out the same biased patterns, effectively locking these communities into an endless loop of surveillance and arrests.</p>
<p>Take a neighborhood with a high number of reported thefts. It may not actually be more crime-ridden—it may simply have had more police patrols for years, leading to more recorded incidents. When an algorithm identifies it as a hotspot, what happens? More patrols, more arrests, and more data reinforcing the cycle. Are we actually preventing crime? Or are we just magnifying a warped picture of reality?</p>
<p>Even worse, this tech obsession distracts us from tackling the real roots of crime. Poverty, inadequate education, housing instability, and a lack of social services all contribute far more to crime than anything an algorithm can detect. Yet instead of investing in job programs, mental health care, or youth services, cities are sinking millions into technologies that just send cops back to the same streets, over and over again. Predictive policing doesn’t solve crime—it sustains it.</p>
<p>Defenders of these systems often argue that algorithms help police allocate resources more efficiently. They claim data helps spot trends that human officers might overlook. But the issue isn’t the presence of data—it’s the quality of that data. Garbage in, garbage out. If you feed inequality into the system, inequality is exactly what you’ll get out. No amount of high-tech modeling can fix a problem it doesn’t even acknowledge.</p>
<p>So, we have to ask: more efficient for whom? Efficiency means little if it comes at the expense of fairness, trust, and justice. Shouldn’t public safety be about protecting <em>everyone</em>, not just upholding old patterns?</p>
<p>Calling for an end to predictive policing isn’t about rejecting technology altogether. It’s about demanding better—tools that address the root causes of crime instead of reinforcing harmful stereotypes. We need solutions rooted in community investment, not automated discrimination.</p>
<p>At a time when America is reckoning with systemic racism and mass incarceration, we simply cannot afford to let flawed algorithms decide who gets policed and who gets left alone. If we truly care about public safety, it’s time to stop feeding this cycle—and start investing in people.</p>
</section>
<section id="updated-ai-score" class="level2">
<h2 class="anchored" data-anchor-id="updated-ai-score">Updated AI Score</h2>
<p>96% AI generated 4% Mixed 0% Human</p>
<p>Suprisingly, the Humanizer GPT returned a higher AI score then before and didn’t create any text that GPTo could register as human. Since the custom GPTs are failing to return better results than the base GPT model, I will try to experiment more with the base model.</p>
<p>I Prompted it with the following:</p>
<p>“This returned an AI score of 78% AI-generated 1% Mixed 21% Human</p>
<p>Could you humanize it more.”</p>
<p>“Let’s Stop Letting Algorithms Decide Who Gets Policed By Ethan Roytman</p>
<p>Imagine being flagged as a potential criminal—not because of something you did, but because of where you live or how often police have historically shown up in your neighborhood. That’s the reality for too many people living in cities across the U.S., thanks to a growing reliance on predictive policing.</p>
<p>At first glance, predictive policing sounds like a smart use of technology. Feed crime data into a computer, let it find patterns, and use those patterns to stop crimes before they happen. Sounds efficient, right?</p>
<p>But here’s the problem: the data being used isn’t neutral. It reflects decades of over-policing in predominantly Black, Latino, and low-income neighborhoods. So when these algorithms predict where police should go next, they usually point right back to the same communities that have been under surveillance for years. It’s not a smarter system—it’s a loop. And the people caught in it are often the ones already struggling under the weight of systemic inequality.</p>
<p>Take a neighborhood with a long history of police presence. Maybe crime gets reported more often there—not because people are committing more crimes, but because police are constantly around, stopping people, writing things up. The algorithm picks up on this and flags the area as “high risk,” leading to even more patrols. It becomes a self-fulfilling prophecy.</p>
<p>Meanwhile, we’re not solving anything. Predictive policing doesn’t ask why crime happens. It doesn’t deal with poverty, joblessness, poor education, or the lack of mental health care. It doesn’t offer hope, opportunity, or safety in any meaningful sense. It just sends more officers into places already stretched thin, while ignoring the deeper reasons people turn to crime in the first place.</p>
<p>Some people argue these algorithms help make police work more effective. That they spot patterns officers might miss. That they save time, resources, and money. But if the patterns are built on flawed data, what are we really improving? Efficiency isn’t a virtue if it’s just making inequality faster.</p>
<p>We’ve reached a point where it’s not enough to ask whether technology works—we have to ask what kind of society it’s helping us build. And right now, predictive policing is pushing us further away from justice, not closer to it.</p>
<p>Ending the use of these algorithms doesn’t mean giving up on public safety. It means rethinking what real safety looks like. It means investing in schools, after-school programs, community centers, jobs. It means understanding that safety isn’t just about stopping bad things from happening—it’s about making good things possible in the first place.</p>
<p>Algorithms don’t have to be villains. But they’re only as fair as the data we feed them—and our criminal justice data is full of bias. Until we fix that, we shouldn’t be using machines to make decisions that affect real people’s lives.</p>
<p>We have the chance to break the cycle. Let’s stop relying on predictive policing and start investing in what truly keeps communities safe.”</p>
</section>
<section id="ai-score" class="level2">
<h2 class="anchored" data-anchor-id="ai-score">AI Score</h2>
<p>84% AI generated 0% Mixed 16% Human</p>
<p>Again, asking for a more humanized version somehow led to a higher AI score. This could imply either a) GPT0 is relatively inaccurate and has a high margin error or b) GPT is relatively ineffective at humanizing and goes in circles.</p>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>Overall, ChatGPT proved to be ineffective at humanizing its outputs, whether it is in the form of asking it directly in a conversation or using an “AI Humanizer” GPT. This makes sense, even though Chat is trying to “humanize” its production, it is still reffering back to old patterns of what “humanized text” looks like - meaning GPT0 is still able to flag it for AI. It is important to know that GPT 0 is a relatively volatile AI checker that admits to having false positives on its website. Personally, I have entered text I fully wrote myself, and it still has flagged it for AI. However, if you do the eye test, all the text generated reads like AI, so I don’t think this is a case of false positives.</p>



</section>

<div class="quarto-listing quarto-listing-container-default" id="listing-listing">
<div class="list quarto-listing-default">

</div>
<div class="listing-no-matching d-none">
No matching items
</div>
</div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/ethanroytman\.github\.io\/comm4190_S25_Using_LLMs_Blog\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>